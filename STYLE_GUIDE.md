# Code Style Guide - Pagemaker

## Overview

This document defines coding standards for the Pagemaker project - a structured document-to-page layout system for Typst. We follow PEP 8 as our foundation with project-specific adaptations for typography, PDF processing, and grid-based layout systems.

## Python Standards and PEP Compliance

### Core Standards
- **PEP 8**: Python Enhancement Proposal 8 (Style Guide for Python Code) is our foundation
- **PEP 484**: Type Hints - Mandatory for all functions and class methods
- **PEP 257**: Docstring Conventions - Required for all public interfaces
- **PEP 20**: The Zen of Python - Guides architectural decisions

### Explicit Deviations from PEP 8
- **Line Length**: 100 characters (matches ruff configuration)
  - Rationale: Typst code generation and complex layout calculations benefit from longer lines
  - Configuration: `ruff format --line-length 100`

### Implicit PEP 8 Adherence
We follow standard PEP 8 guidelines for:
- Indentation (4 spaces, no tabs)
- Blank lines (2 for top-level functions/classes, 1 for methods)
- Imports organization and ordering
- Naming conventions (detailed below)

## Naming Conventions

### Variables and Functions
```python
# snake_case for variables, functions, and methods
page_dimensions: tuple[float, float] = (210, 297)
grid_cols: int = 12
typst_output: str = ""

def generate_typst_code(ir: dict) -> str:
    pass

def _render_text_element(element: dict) -> str:  # Private functions with leading underscore
    pass
```

### Classes and Types
```python
# PascalCase for classes, enums, and type aliases
class TypstGenerator:
    pass

class ElementType(Enum):
    TEXT = "text"
    IMAGE = "image"
    PDF = "pdf"
    RECTANGLE = "rectangle"

# Type aliases for complex types
IRDict = Dict[str, Any]
ElementList = List[Dict[str, Any]]
StyleMap = Dict[str, Dict[str, str]]
```

### Constants
```python
# SCREAMING_SNAKE_CASE for module-level constants
DEFAULT_PAGE_WIDTH_MM: float = 210.0
DEFAULT_PAGE_HEIGHT_MM: float = 297.0
SUPPORTED_IMAGE_FORMATS: Set[str] = {".jpg", ".jpeg", ".png", ".svg"}
TYPST_HEADER_TEMPLATE: str = "// Generated by pagemaker"
```

### Module and Package Names
```python
# lowercase with underscores for readability
src/pagemaker/
├── __init__.py
├── cli.py
├── parser.py                    # Org-mode parsing
├── generator.py                 # Typst code generation
├── validation.py                # Input validation
├── generation/                  # Modular generation system
│   ├── __init__.py
│   ├── core.py                  # Main orchestration
│   ├── elements.py              # Element rendering
│   ├── layout.py                # Grid and positioning
│   └── pdf_processor.py         # PDF handling
└── utils/                       # Shared utilities
    ├── __init__.py
    ├── alignment.py             # Position calculations
    ├── font_discovery.py        # Font scanning
    └── typst_helpers.py          # Typst code utilities
```

## Type Annotations

### Mandatory Type Hints
**All functions and methods must include type annotations:**

```python
# Function signatures - explicit input/output types
def render_grid_element(
    element: Dict[str, Any],
    grid_cols: int,
    grid_rows: int,
    cell_width_mm: float,
    cell_height_mm: float
) -> str:
    pass

# Class methods - include self parameter typing when needed
class TypstGenerator:
    def __init__(self, ir: IRDict) -> None:
        self.ir = ir

    def generate_page_setup(self, page_settings: Dict[str, Any]) -> str:
        pass
```

### Complex Type Annotations
```python
from typing import Dict, List, Optional, Union, Callable, TypeVar, Tuple

# Type variables for generic classes
T = TypeVar('T')
ElementT = TypeVar('ElementT', bound=Dict[str, Any])

# Complex nested types for pagemaker domain
PageSettings = Dict[str, Union[str, int, float, List[float]]]
GridCoordinates = Tuple[int, int, int, int]  # (x, y, w, h)
StyleDeclaration = Dict[str, Union[str, int, float]]
FontMapping = Dict[str, List[Dict[str, Union[str, int]]]]

# Callable types for processing functions
ElementRenderer = Callable[[Dict[str, Any]], str]
StyleProcessor = Callable[[str], StyleDeclaration]
```

### Domain-Specific Type Aliases
```python
# Pagemaker-specific type definitions
class Coordinates(TypedDict):
    x: int
    y: int 
    w: int
    h: int

class ElementData(TypedDict):
    type: str
    area: Coordinates
    content: Optional[str]
    style: Optional[str]
    padding: Optional[List[float]]

class PageData(TypedDict):
    master_def: Optional[str]
    page_size: Dict[str, float]
    elements: List[ElementData]
```

## Import Organization

### Import Order (PEP 8 Compliant)
```python
"""Module docstring describing page layout functionality."""

# 1. Standard library imports
import datetime
import pathlib
import re
import warnings
from typing import Any, Dict, List, Optional, Tuple

# 2. Third-party imports  
from fontTools.ttLib import TTFont
from fontTools.ttLib.ttCollection import TTCollection

# 3. Local application imports
from pagemaker.utils.alignment import normalize_alignment, get_alignment_wrapper
from pagemaker.utils.font_discovery import discover_available_fonts
from pagemaker.utils.typst_helpers import escape_typst_text, build_text_args
```

### Import Style Guidelines
```python
# Prefer absolute imports for clarity
from pagemaker.generation.core import generate_typst  # ✓ Good
from .core import generate_typst  # ✗ Avoid relative imports

# Group related imports logically
from pagemaker.utils.typst_helpers import (
    build_page_setup,
    build_text_args,
    build_typst_comment,
    escape_typst_text,
    format_dimensions,
)

# Use aliases for frequently used long names
import pathlib as pl
from collections import defaultdict as dd
```

## Code Documentation

### Module Docstrings (PEP 257)
```python
"""
Typst code generation for grid-based page layouts.

This module handles the conversion from intermediate representation (IR) to 
Typst markup, supporting precise element positioning, professional typography,
and PDF embedding with MuchPDF integration.

Classes:
    TypstGenerator: Main code generation orchestrator
    StyleProcessor: Style declaration parsing and validation
    GridCalculator: Grid positioning and dimension calculations

Functions:
    generate_typst: Main entry point for IR to Typst conversion
    render_text_element: Generate Typst code for text elements
    calculate_cell_dimensions: Compute grid cell sizes from page dimensions

Example:
    >>> from pagemaker.generator import generate_typst
    >>> typst_code = generate_typst(intermediate_representation)
    >>> with open("output.typ", "w") as f:
    ...     f.write(typst_code)
"""
```

### Function and Method Docstrings
```python
def render_pdf_element(
    element: Dict[str, Any],
    cell_width: float,
    cell_height: float,
    padding: Optional[List[float]] = None
) -> str:
    """
    Generate Typst code for PDF element with automatic contain scaling.

    Renders a PDF element using MuchPDF with auto-contain scaling that ensures
    the PDF content fits entirely within the element's padded frame. Handles
    path resolution, scale calculation, and alignment positioning.

    Args:
        element: Element dict with 'path', 'area', and optional 'align'/'valign'
        cell_width: Grid cell width in mm
        cell_height: Grid cell height in mm  
        padding: Optional padding [top, right, bottom, left] in mm

    Returns:
        Typst code string for PDF embedding with proper positioning

    Raises:
        ValueError: If element lacks required 'path' or 'area' keys
        FileNotFoundError: If PDF file cannot be located
        PDFProcessingError: If PDF dimensions cannot be determined

    Example:
        >>> element = {"type": "pdf", "path": "diagram.pdf", "area": [1, 1, 4, 3]}
        >>> typst_code = render_pdf_element(element, 17.5, 18.0)
        >>> print(typst_code)
        #layer_mm(17.5mm, 18.0mm, 0mm, 0mm, 1, 1, 4, 3)[
          #PdfEmbed("diagram.pdf", scale: 0.85)
        ]
    """
```

### Class Docstrings
```python
class StyleProcessor:
    """
    Advanced style declaration parser for pagemaker typography.

    Parses CSS-like style declarations into structured data for Typst code
    generation. Supports font families, weights, sizes, colors, and paragraph
    formatting options with validation and normalization.

    Attributes:
        valid_weights: Set of supported font weight values
        valid_linebreaks: Set of supported linebreak modes
        style_aliases: Mapping of style property aliases

    Example:
        >>> processor = StyleProcessor()
        >>> style_dict = processor.parse("font: Inter, weight: bold, size: 24pt")
        >>> print(style_dict)
        {'font': 'Inter', 'weight': 'bold', 'size': '24pt'}
    """
```

## Error Handling and Exceptions

### Exception Hierarchy
```python
# Custom exception hierarchy with descriptive names
class PagemakerError(Exception):
    """Base exception for pagemaker operations."""
    pass

class ParseError(PagemakerError):
    """Raised when parsing Org-mode or style declarations fails."""
    pass

class ValidationError(PagemakerError):
    """Raised when input validation fails."""
    pass

class TypstGenerationError(PagemakerError):
    """Raised when Typst code generation encounters errors."""
    pass

class FontDiscoveryError(PagemakerError):
    """Raised when font discovery or validation fails."""
    pass

class PDFProcessingError(PagemakerError):
    """Raised when PDF processing operations fail."""
    pass
```

### Error Handling Patterns
```python
# Specific exception handling with context preservation
try:
    pdf_width_mm, pdf_height_mm = get_pdf_dimensions(pdf_path)
    if pdf_width_mm <= 0 or pdf_height_mm <= 0:
        raise PDFProcessingError(f"Invalid PDF dimensions: {pdf_width_mm}x{pdf_height_mm}mm")
except FileNotFoundError as e:
    logger.error(f"PDF file not found: {pdf_path}")
    raise PDFProcessingError(f"Cannot find PDF file: {pdf_path}") from e
except Exception as e:
    logger.error(f"PDF processing failed for {pdf_path}: {e}")
    raise PDFProcessingError(f"Failed to process PDF: {pdf_path}") from e

# Validation with user-friendly messages
def validate_grid_area(area: List[int], grid_cols: int, grid_rows: int) -> None:
    """Validate grid area coordinates against grid bounds."""
    if len(area) != 4:
        raise ValidationError(f"Area must have 4 coordinates [x,y,w,h], got {len(area)}")
    
    x, y, w, h = area
    if x < 1 or y < 1:
        raise ValidationError(f"Grid coordinates start at 1, got x={x}, y={y}")
    
    if x + w - 1 > grid_cols:
        raise ValidationError(f"Area extends beyond grid: x={x}, w={w} exceeds {grid_cols} columns")
```

## Logging Standards

### Logger Configuration
```python
import logging

# Module-level logger with qualified name
logger = logging.getLogger(__name__)

# Consistent log message formatting for pagemaker operations
logger.info(f"Generating Typst code for {len(ir['pages'])} pages")
logger.warning(f"Font family '{font_name}' not found, Typst will use fallback")
logger.error(f"PDF processing failed for {pdf_path}: {error_details}")

# Use structured logging for important generation events
logger.info(
    "Typst generation completed",
    extra={
        "page_count": len(ir['pages']),
        "element_count": total_elements,
        "generation_time_ms": generation_time,
        "output_size_bytes": len(typst_output)
    }
)
```

## CLI Interface Standards

### Click Framework Usage
```python
import click
from pathlib import Path

# Consistent option naming and help text for pagemaker CLI
@click.command()
@click.argument("input_file", type=click.Path(exists=True, path_type=Path))
@click.option(
    "--output-dir", "-o",
    default="./output",
    type=click.Path(file_okay=False, dir_okay=True, path_type=Path),
    help="Output directory for generated Typst files",
)
@click.option(
    "--page-size",
    default="A4",
    type=click.Choice(["A4", "A3", "A5", "Letter", "Legal"]),
    help="Target page size for layout generation",
)
@click.option(
    "--grid-size",
    default="12x16",
    help="Grid dimensions as 'COLSxROWS' (e.g., '12x16')",
)
def generate(input_file: Path, output_dir: Path, page_size: str, grid_size: str):
    """
    Generate Typst layout from Org-mode input with precise grid positioning.

    INPUT_FILE should be an Org-mode file with pagemaker markup.
    Generated .typ files will be written to the output directory.
    """
```

### User Feedback Standards
```python
# Consistent progress indication and error reporting
click.echo(f"Processing {input_file.name}...")
click.echo(f"Grid: {grid_cols}×{grid_rows}, Page: {page_size}")

with click.progressbar(
    ir['pages'],
    label="Generating pages",
    length=len(ir['pages'])
) as progress:
    for page in progress:
        process_page(page)

# Success and error formatting with pagemaker context
click.secho("✓ Typst generation completed successfully", fg='green')
click.secho(f"→ Output: {output_path}", fg='blue')
click.secho(f"✗ Error: Invalid grid area {area} on page {page_num}", fg='red', err=True)
```

## File and Directory Conventions

### Project Structure
```
src/pagemaker/                   # Main package
├── __init__.py                  # Package initialization and version
├── cli.py                       # Command-line interface
├── parser.py                    # Org-mode parsing logic  
├── generator.py                 # Legacy Typst generation (being refactored)
├── validation.py                # Input validation and sanitization
├── table_render.py              # Table layout rendering
└── generation/                  # Modular generation system
    ├── __init__.py
    ├── core.py                  # Main generation orchestration
    ├── elements.py              # Element type rendering
    ├── layout.py                # Grid and positioning calculations
    └── pdf_processor.py         # PDF handling and scaling
└── utils/                       # Shared utility modules
    ├── __init__.py
    ├── alignment.py             # Position and alignment calculations
    ├── file_ops.py              # File operations and path handling
    ├── font_discovery.py        # Font scanning and caching
    └── typst_helpers.py          # Typst code generation utilities

tests/                           # Test suite (mirrors src structure)
├── fixtures/                    # Test input files
│   ├── basic.org
│   ├── edge_cases.org
│   └── pdf_test.org
├── integration/                 # Integration tests
│   ├── test_pipeline.py         # End-to-end processing tests
│   └── test_pdf_compile_cli.py  # CLI integration tests
└── unit/                        # Unit tests
    ├── test_generator.py        # Core generation logic tests
    ├── test_parser.py           # Org-mode parsing tests
    └── test_validation.py       # Validation logic tests

examples/                        # Example documents and assets
├── assets/                      # Test images, fonts, PDFs
└── *.org                        # Example Org-mode files
```

### File Naming
```python
# Module files: descriptive, snake_case focused on pagemaker domain
pdf_processor.py          # ✓ Clear PDF handling purpose
font_discovery.py         # ✓ Descriptive font functionality
typst_helpers.py          # ✓ Specific utility purpose
utils.py                  # ✗ Too generic
helper.py                 # ✗ Unclear purpose

# Test files: mirror source structure with test_ prefix
test_pdf_processor.py     # Tests for pdf_processor.py
test_integration.py       # Integration tests for full pipeline
```

## Configuration and Settings

### Environment Configuration
```python
# Configuration is primarily handled through CLI arguments and file-based settings
# Avoid complex configuration systems for this focused tool

# Simple settings for development/testing
from typing import Optional
from pathlib import Path

class PagemakerSettings:
    """Simple configuration for pagemaker processing."""
    
    def __init__(self):
        self.default_page_size: str = "A4"
        self.default_grid_cols: int = 12
        self.default_grid_rows: int = 16
        self.default_margins: list[float] = [15.0, 15.0, 15.0, 15.0]
        
        # Font discovery paths
        self.font_search_paths: list[str] = [
            "assets/fonts",
            "examples/assets/fonts",
            "src/pagemaker/fonts"
        ]
        
        # Output formatting
        self.typst_header_comment: str = "// Generated by pagemaker"
        self.debug_grid_enabled: bool = False

# Use simple dataclass for page-specific settings
@dataclass
class PageConfig:
    """Configuration for individual page processing."""
    width_mm: float = 210.0
    height_mm: float = 297.0
    margin_mm: list[float] = field(default_factory=lambda: [15.0, 15.0, 15.0, 15.0])
    grid_cols: int = 12
    grid_rows: int = 16
    show_debug_grid: bool = False
```

## Testing Standards

### Test Organization
```python
# Clear test class and method naming focused on pagemaker functionality
class TestTypstGeneration:
    """Test suite for Typst code generation functionality."""

    def test_text_element_renders_with_correct_positioning(self):
        """Should generate proper layer() calls for text elements."""

    def test_pdf_element_calculates_auto_contain_scaling(self):
        """Should apply correct scaling to fit PDF within element bounds."""

    def test_grid_coordinates_convert_to_typst_positioning(self):
        """Should convert A1-style coordinates to Typst layer positioning."""

# Fixture naming and organization
@pytest.fixture
def sample_ir() -> Dict[str, Any]:
    """Generate realistic intermediate representation for testing."""
    return {
        "meta": {"THEME": "light"},
        "pages": [{
            "page_size": {"w_mm": 210, "h_mm": 297},
            "grid": {"cols": 12, "rows": 16},
            "elements": [
                {
                    "type": "text",
                    "area": [1, 1, 4, 2],
                    "content": "Sample text content",
                    "style": "font: Inter, size: 12pt"
                }
            ]
        }]
    }

@pytest.fixture
def typst_generator(sample_ir) -> TypstGenerator:
    """Configured TypstGenerator instance with test data."""
    return TypstGenerator(sample_ir)
```

### Test Data Management
```python
# Prefer realistic test data that matches pagemaker's domain
def create_test_element(
    element_type: str = "text",
    area: List[int] = None,
    content: str = "Test content"
) -> Dict[str, Any]:
    """Generate realistic element for testing."""
    if area is None:
        area = [1, 1, 2, 1]  # Default 2x1 area
    
    element = {
        "type": element_type,
        "area": area,
        "content": content
    }
    
    # Add type-specific properties
    if element_type == "pdf":
        element["path"] = "test-assets/sample.pdf"
    elif element_type == "image":
        element["path"] = "test-assets/sample.jpg"
        
    return element

def create_test_page(
    grid_cols: int = 12,
    grid_rows: int = 16,
    elements: Optional[List[Dict[str, Any]]] = None
) -> Dict[str, Any]:
    """Generate realistic page data for testing."""
    if elements is None:
        elements = [create_test_element()]
    
    return {
        "page_size": {"w_mm": 210, "h_mm": 297},
        "grid": {"cols": grid_cols, "rows": grid_rows},
        "elements": elements
    }
```

## Performance Guidelines

### Data Processing
```python
# Use efficient data structures for large documents
from collections import defaultdict

def group_elements_by_type(elements: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
    """Group elements by type for batch processing."""
    grouped: defaultdict[str, List[Dict[str, Any]]] = defaultdict(list)
    for element in elements:
        element_type = element.get("type", "unknown")
        grouped[element_type].append(element)
    return dict(grouped)

# Process elements efficiently with generators for large documents
def render_elements(elements: List[Dict[str, Any]]) -> Iterator[str]:
    """Render elements efficiently using generators."""
    for element in elements:
        yield render_single_element(element)

# Cache expensive operations like font discovery
@functools.lru_cache(maxsize=1)
def get_available_fonts() -> Dict[str, List[Dict[str, Any]]]:
    """Cache font discovery results for performance."""
    return discover_available_fonts()
```

### Memory Management
```python
# Use __slots__ for data classes with many instances in large documents
@dataclass
class GridPosition:
    __slots__ = ['x', 'y', 'w', 'h', 'padding']
    
    x: int
    y: int
    w: int
    h: int
    padding: Optional[List[float]] = None

# Context managers for file operations
class TypstOutputWriter:
    def __init__(self, output_path: Path):
        self.output_path = output_path
        self.file_handle = None
    
    def __enter__(self) -> 'TypstOutputWriter':
        self.file_handle = self.output_path.open('w', encoding='utf-8')
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.file_handle:
            self.file_handle.close()
```

## Security Guidelines

### Data Handling
```python
# Sanitize file paths for security
def sanitize_asset_path(path: str) -> str:
    """Sanitize asset paths to prevent directory traversal."""
    # Remove dangerous path components
    sanitized = str(Path(path).resolve())
    # Ensure path is within allowed directories
    allowed_dirs = ["assets", "examples", "src/pagemaker/fonts"]
    if not any(sanitized.startswith(str(Path(dir).resolve())) for dir in allowed_dirs):
        raise ValidationError(f"Asset path outside allowed directories: {path}")
    return sanitized

# Validate user input for grid coordinates
def validate_grid_coordinates(x: int, y: int, w: int, h: int, max_cols: int, max_rows: int) -> None:
    """Validate grid coordinates are within bounds."""
    if not all(isinstance(coord, int) for coord in [x, y, w, h]):
        raise ValidationError("Grid coordinates must be integers")
    
    if x < 1 or y < 1 or w < 1 or h < 1:
        raise ValidationError("Grid coordinates must be positive")
    
    if x + w - 1 > max_cols or y + h - 1 > max_rows:
        raise ValidationError(f"Grid area exceeds bounds: {max_cols}x{max_rows}")
```

## Development Workflow

### Local Development Standards
All code quality assurance is performed locally using ruff:

```bash
# Required pre-commit workflow
pip install -e ".[dev]"          # Install with development dependencies
pre-commit install               # Install git hooks (if using pre-commit)

# Manual quality checks
ruff check src/                  # Linting with pagemaker-specific rules  
ruff format src/                 # Code formatting (100 char line length)
python -m pytest                # Run test suite

# Type checking (optional, not enforced yet due to legacy code)
mypy src/ --ignore-missing-imports
```

### Ruff Configuration
The project uses a permissive ruff configuration to accommodate the existing codebase during refactoring:

```toml
[tool.ruff]
target-version = "py39"
line-length = 100

[tool.ruff.lint]
select = ["E", "F", "I", "B", "UP"]
ignore = [
  "E501",  # line length (many long Typst strings)
  "B028",  # warnings.warn stacklevel
  "B007",  # unused loop vars in readable loops
  "F841",  # allow unused variables during refactoring
]
```

### Code Review Guidelines
```python
# Self-documenting code reduces review overhead for pagemaker domain
class TypstElementRenderer:
    """Renders individual elements to Typst code with precise positioning."""

    def render_text_with_style(self, content: str, style_dict: Dict[str, str]) -> str:
        """Render text content with applied typography styles."""
        text_args = self._build_text_arguments(style_dict)
        escaped_content = escape_typst_text(content)
        return f"#text({text_args})[{escaped_content}]"
```

## Pagemaker-Specific Guidelines

### Typst Code Generation
```python
# Generate clean, readable Typst code
def build_layer_call(x: int, y: int, w: int, h: int, content: str) -> str:
    """Build Typst layer() function call with proper formatting."""
    return f"#layer({x}, {y}, {w}, {h})[\n  {content}\n]"

# Use consistent indentation in generated Typst
def indent_typst_content(content: str, levels: int = 1) -> str:
    """Indent Typst content consistently."""
    indent = "  " * levels
    return "\n".join(f"{indent}{line}" if line.strip() else line for line in content.split("\n"))
```

### Grid System Standards
```python
# Always validate grid coordinates
def ensure_valid_area(area: List[int], grid_cols: int, grid_rows: int) -> None:
    """Ensure area coordinates are valid for the current grid."""
    x, y, w, h = area
    if x + w - 1 > grid_cols or y + h - 1 > grid_rows:
        raise ValidationError(f"Area {area} exceeds grid bounds {grid_cols}x{grid_rows}")

# Use consistent coordinate naming
# x, y: top-left position (1-based)
# w, h: width and height in grid cells
# Always use [x, y, w, h] order in area lists
```

This style guide ensures consistency, maintainability, and professional code quality while addressing the specific needs of the pagemaker project's typography and layout generation systems.